"use strict";(self.webpackChunkgeyser_wiki=self.webpackChunkgeyser_wiki||[]).push([[8130],{77735:e=>{e.exports=JSON.parse('{"archive":{"blogPosts":[{"id":"raknet-amplification-attack","metadata":{"permalink":"/blog/raknet-amplification-attack","source":"@site/blog/2024-05-05-raknet-amplification-attack.md","title":"RakNet Amplification Attack Summary and Response","description":"A look at how we dealt with an exploit in the RakNet protocol","date":"2024-05-05T00:00:00.000Z","tags":[],"readingTime":17.7,"hasTruncateMarker":true,"authors":[{"name":"Kas-tle","title":"Developer","url":"https://github.com/Kas-tle","imageURL":"https://github.com/Kas-tle.png","key":"Kas-tle","page":null}],"frontMatter":{"title":"RakNet Amplification Attack Summary and Response","slug":"raknet-amplification-attack","authors":"Kas-tle","hide_table_of_contents":false,"description":"A look at how we dealt with an exploit in the RakNet protocol"},"unlisted":false,"nextItem":{"title":"Geyser Available for Java 1.20.5/1.20.6","permalink":"/blog/geyser-1-20-5"}},"content":"In March, we were made aware of an exploit in the RakNet networking library used by Geyser, making Geyser instances vulnerable to use in a Distributed Denial of Service (DDoS) amplification attack. This bug was patched on all builds of Geyser numbered 478 and later. If you are still running an outdated build of Geyser, you should update immediately by downloading the latest build from [https://geyser.fastly.8aka.cn/download](https://geyser.fastly.8aka.cn/download). The original [security advisory](https://github.com/CloudburstMC/Network/security/advisories/GHSA-6h3m-c6fv-8hvh) for this vulnerability was published on the [CloudburstMC/Network](https://github.com/CloudburstMC/Network) repository. This post will detail the timeline, anatomy of the attack, our response, and additional measures we have taken to prevent similar attacks in the future.\\n\\n\x3c!-- truncate --\x3e\\n\\n## Timeline (UTC)\\n\\n* **March 24th, 11:00AM**: bStats data begins to show instability in the number of online Geyser instances\\n* **March 28th,  5:00AM**: First reported Geyser instance causing server suspension by OVH\\n* **March 28th,  4:00PM**: First GitHub issue is opened referencing spamming of suspicious connections \\n* **March 28th,  5:00PM**: Attack against the Global Linking Server, which also hosts the Global API and Geyser Test Server, takes all three services offline\\n* **March 28th,  6:07PM**: The Global API server is started to begin restoration of the database from the MariaDB log\\n* **March 28th,  6:27PM**: The packets sent from Geyser responsible for the suspension of the Geyser Test Server machine are identified as being 134 bytes each sent at a rate of 60,000 packets per second\\n* **March 28th,  6:30PM**: A build of Geyser with enhanced logging for the Cloudburst Network library is installed on the test server to gather data about the attack vector.\\n* **March 28th,  7:48PM**: Database restoration is completed and the Global API is brought back online, but remains unstable due to the initial backlog of requests from the downtime\\n* **March 28th,  8:46PM**: Global API stability returns to normal\\n* **March 29th,  1:30AM**: Initial rate limiting is implemented in Geyser from upstream changed in Cloudburst Network, but the specific attack vector is still unclear \\n* **March 29th,  3:32AM**: Packet responsible is identified as Connection Request Accepted, sent by Geyser in the initial RakNet handshake\\n* **March 29th,  6:00AM**: Initial proof of concept is created showing a client can maliciously spam Connection Request packets, causing the server to reply with larger Connection Request Accepted packets\\n* **March 29th, 12:25PM**: Further rate limiting is added to Geyser via Cloudburst Network, particularly for replies to Connection Request packets\\n* **March 30th,  9:20AM**: A raw packet capture is obtained from a Geyser instance under attack, unmasking the root cause of the issue as the RakNet reliability setting of the Connection Request Accepted packet in Cloudburst Network\\n* **March 30th, 10:30AM**: A final fix to Cloudburst Network is pushed to Geyser, and a previously exploited instance is monitored with full packet dumps to confirm the fix\\n* **March 30th, 10:28PM**: Security advisory is published on the Cloudburst Network GitHub repository\\n* **March 30th, 10:31PM**: First @everyone ping in 1 year is made in the Geyser Discord announcing the security advisory and requesting all server owners update their instances as soon as possible\\n\\n\\n## Initial Warning Signs\\n\\nBefore the issue was initially detected, a suspicious trend can be seen in Geyser\u2019s bStats data. On March 24th starting at approximately 11:00AM UTC, noticeable dips are seen in the total number of online Geyser instances. Normally, the number of online instances smoothly climbs and falls by about 500 instances, likely correlating with when people have free time to play Minecraft. Beginning on March 24th, frequent hourly swings of as much as 2200 instances online are seen. Given hindsight, this is likely when wide scale exploitation of this attack began.\\n\\n| ![Geyser bStats Usage](/img/blog/2024-05-05-raknet-amplification-attack/geyser-bstats-usage.png) |\\n|:--:| \\n| *bStats chart of servers using Geyser over the month of March. Clear instability in the number of online servers reported is seen at the left starting on March 24th, at least three days before any formal reports of the attack were received.* |\\n\\n\\n## Initial Disclosure\\n\\nMultiple users in the Geyser Discord first brought the attack to our attention by providing us with notices from their hosting provider that their server instances were suspended due to abuse. This means that their Geyser instances were sending outbound traffic interpreted by their hosting provider interpreted as a denial of service attack. Here is a snippet from one of these notices:\\n\\n\\n```sh\\n##############################################################################\\n#       DDoS-Attack detected from host XXX.XXX.XXX.XXX                       #\\n##############################################################################\\n\\nTIME                             \\tSRC       \\tSRC-PORT  ->  DST       \\tDST-PORT  SIZE  PROT\\n----------------------------------------------------------------------------------------------------------\\n2024-03-28 06:49:06.493070866 +0100  XXX.XXX.XXX.XXX\\t19132  ->  51.75.XXX.XXX    \\t1   134   UDP\\n2024-03-28 06:49:06.50822918  +0100  XXX.XXX.XXX.XXX\\t19132  ->  51.75.XXX.XXX    \\t1   134   UDP\\n2024-03-28 06:49:06.515954324 +0100  XXX.XXX.XXX.XXX\\t19132  ->  51.75.XXX.XXX    \\t1   134   UDP\\n2024-03-28 06:49:06.519665639 +0100  XXX.XXX.XXX.XXX\\t19132  ->  51.75.XXX.XXX    \\t1   134   UDP\\n2024-03-28 06:49:06.523410527 +0100  XXX.XXX.XXX.XXX\\t19132  ->  51.75.XXX.XXX    \\t1   134   UDP\\n2024-03-28 06:49:06.526647418 +0100  XXX.XXX.XXX.XXX\\t19132  ->  51.75.XXX.XXX    \\t1   134   UDP\\n2024-03-28 06:49:06.53355138  +0100  XXX.XXX.XXX.XXX\\t19132  ->  51.75.XXX.XXX    \\t1   134   UDP\\n2024-03-28 06:49:06.537470479 +0100  XXX.XXX.XXX.XXX\\t19132  ->  51.75.XXX.XXX    \\t1   134   UDP\\n```\\n*Abuse report from OVH regarding the suspension of server running a Geyser instance.*\\n\\nThis is the first information we were presented with regarding the attack vector. Based on this, we  can determine the rough speed of the attack by subtracting the time of the last packet in the report from the first packet (0.044399613 seconds) and dividing the packets sent in that timeframe (8 packets) by the time, we can see about 180 packets per second are being sent here. We are also given the size of the packet on the wire, which is 134 bytes. It\u2019s important to note that this is the size of the packet as it exits the provider network, so it should only contain the destination headers for the public IP address.\\n\\nLogs were also provided by another user, which show that after many repeated connection attempts, Cloudburst Network was unable to keep up and packet byte buffer handling was compromised.\\n\\n```log\\n[nioEventLoopGroup-5-1/ERROR] [org.cloudburstmc.netty.channel.raknet.RakChannelPipeline]: Exception thrown in RakNet pipeline\\nio.netty.handler.codec.DecoderException: java.lang.NullPointerException: Cannot invoke \\"io.netty.buffer.ByteBuf.release()\\" because \\"this.buffer\\" is null\\n  at io.netty.handler.codec.MessageToMessageDecoder.channelRead(MessageToMessageDecoder.java:98)\\n  at io.netty.handler.codec.MessageToMessageCodec.channelRead(MessageToMessageCodec.java:111)\\n  at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:442)\\n  at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:420)\\n  at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:412)\\n  at io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1410)\\n  at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:440)\\n  at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:420)\\n  at io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:919)\\n  at org.cloudburstmc.netty.handler.codec.raknet.server.RakServerRouteHandler.channelRead(RakServerRouteHandler.java:60)  \\n  ...\\n  at org.cloudburstmc.netty.handler.codec.raknet.AdvancedChannelInboundHandler.channelRead(AdvancedChannelInboundHandler.java:48)\\n  ...\\n  at org.geysermc.geyser.network.netty.handler.RakConnectionRequestHandler.channelRead(RakConnectionRequestHandler.java:80)\\n  ...\\n  at org.cloudburstmc.netty.handler.codec.raknet.ProxyInboundRouter.channelRead(ProxyInboundRouter.java:66)\\n  ...\\nCaused by: java.lang.NullPointerException: Cannot invoke \\"io.netty.buffer.ByteBuf.release()\\" because \\"this.buffer\\" is null\\n  at org.cloudburstmc.netty.channel.raknet.packet.EncapsulatedPacket.deallocate(EncapsulatedPacket.java:138)\\n  ... 45 more\\n```\\n*Stacktrace from an attacked server after many hours of connection attempts, showing instability in the ability of Cloudburst Network to process packets.*\\n\\n\\n## Reproduction Attempts\\n\\nGiven that the packet spam was occurring without Bedrock login taking place, the vulnerability was likely in the initial establishment of the RakNet connection. Minecraft Bedrock Edition uses a modified version of the RakNet protocol which has gone largely unchanged for many years and is unofficially documented at [https://wiki.vg/Raknet_Protocol](https://wiki.vg/Raknet_Protocol). Before game packets are sent, the connection is established with 7 packets, four of which are sent by the client and three of which are sent by the server. It was likely that one of these three packets was being spammed by the Geyser instance. The initial RakNet connection follows the sequence:\\n\\n```sh\\n[Client -> Server] Open Connection Request 1\\n[Server -> Client] Open Connection Reply 1\\n[Client -> Server] Open Connection Request 2\\n[Server -> Client] Open Connection Reply 2\\n\\nRakNet connection is established and further messages now wrapped in Frame Set Packet\\n\\n(FSP) [Client -> Server] Connection Request\\n(FSP) [Server -> Client] Connection Request Accepted\\n(FSP) [Client -> Server] New Incoming Connection\\n```\\n*Summary of the RakNet initial connection sequence. Note that the ability to utilize RakNet reliability settings begin only once packets are wrapped in a Frame Set Packet.*\\n\\nGiven that the packet being spammed is coming from the server, and given it has a known outbound length of 134 bytes, we can analyze a normal connection to Geyser in Wireshark to determine the most likely responsible packet:\\n\\n| ![Wireshark Initial RakNet Connection](/img/blog/2024-05-05-raknet-amplification-attack/wireshark-initial-raknet-connection.png) |\\n|:--:|\\n| *Wireshark packet capture of a Geyser server at the initial RakNet connection stage. A hex dump of the Connection Request Accepted packet, sent by the server to the client, is shown. Note that byte numbers start at 0.* |\\n\\nWe can see that on the client end, Connection Request Accepted is 148 bytes over the wire. However, if we subtract the 14 bytes of headers (bytes 0 to 13) added by the local network for routing, we get a size of 134 bytes when the packet left the provider network. Knowing this packet is likely responsible, we can consider how we might get the server to send many of them. One somewhat naive approach we took initially was sending many Connection Request packets once receiving Open Connection Reply 2 from the server. This does indeed result in the server sending many connection request accepted packets, showing there indeed was potential for abuse in Cloudburst Network\u2019s existing implementation:\\n\\n| ![Wireshark Reproduction Attempt](/img/blog/2024-05-05-raknet-amplification-attack/wireshark-reproduction-attempt.png) |\\n|:--:|\\n| *Wireshark packet capture of a Geyser instance after being sent hundreds of Connection Request packets by a single client. The Geyser instance consequently replies with an equal number of Connection Request Accepted packets.* |\\n\\nThat said, this is at best an amplification factor of two. By now, we had some bandwidth data of the attack, showing an amplification factor of at least 350 in the wild. Given this, there must have been a way to get this packet to be sent many more times.\\n\\n| ![Pterodactyl Outbound Spike](/img/blog/2024-05-05-raknet-amplification-attack/pterodactyl-outbound-spike.png) |\\n|:--:|\\n| *Pterodactyl Panel dashboard of a Paper server running Geyser during an attack, showing a large outbound traffic spike. Within the short attack period, inbound traffic is only 819KiB, while outbound traffic is nearly 300MiB.* |\\n\\n\\n## Live Analysis\\n\\nOne thing that worked in our favor, ironically, was the wide scale exploitation of this vulnerability. Since our own official test server, and even some of our personal servers, were actively being attacked at regular intervals, we had ample locations to gather data about the attack. We began taking full raw packet capture of a server actively being attacked, which would ultimately unveil the root cause of the attack.\\n\\n| ![Wireshark Live Attack](/img/blog/2024-05-05-raknet-amplification-attack/wireshark-live-attack.png) |\\n|:--:|\\n| *Wireshark packet capture of a Geyser instance under attack. The highlighted packet is a NAK packet sent by the client to the Geyser instance requesting the server resend packets with sequence numbers ranging from 0 to 8191. The immediately following packet is similar, requesting packets 8192 to 16383. The attacker sent these at the beginning of the connection and then simply waited while the Geyser instance continued to send thousands of packets, with each one incrementing the sequence number, leading to yet more packets being sent until the malicious NAK requests were fulfilled.* |\\n\\nLooking at the packets sent by the attacker, we see that things largely follow the specified connection sequence. But we also see a new type of packet as well: a NAK packet with a range of 0 to 8191. This brings us to the topic of RakNet packet reliability.\\n\\nSince UDP itself does not have an inbuilt handshake like TCP to ensure all data arrives bit perfect in the correct order, RakNet implements a reliability system as a substitute. For this system, each packet is sent with a reliability type. While RakNet has eight reliability types, understanding this vulnerability only requires us to understand the difference between reliable and unreliable packets. Simply put, the client can request that reliable packets be resent, while it cannot request the resend of unreliable packets. Looking at the Cloudburst Network library, we see that this packet was indeed sent as reliable.\\n\\n| ![RakServerOnlineInitialHandler](/img/blog/2024-05-05-raknet-amplification-attack/rak-server-online-initial-handler.png) |\\n|:--:|\\n| *RakServerOnlineInitialHandler#sendConnectionRequestAccepted is responsible for sending the Open Connection Request packet in the initial connection sequence. The RakReliability.RELIABLE enum causes the packet to be cached by the server before it is sent, therefore allowing the client to later re-request it via NAK.* |\\n\\nBecause the packet was marked as reliable, this means that Network allows the client to respond with an ACK (Positive Acknowledgement) or NAK (Negative Acknowledgement). At this stage in the connection, this is a vector for abuse because the client has not yet done anything to prove that we are communicating with them directly versus receiving UDP packets with spoofed IP headers. By sending a NAK with the maximum range, they force us to continuously send the Connection Request Accepted packet.\\n\\n\\n## Effects\\n\\nThis begs the question though: why would an attacker bother doing this? The two leading theories are UDP amplification, meaning the goal is to use Geyser instances as a means to attack other servers, or provider-based suspension, meaning the goal is to get the servers running Geyser instances suspended by their hosting provider.\\n\\n\\n### UDP Amplification\\n\\nAs explained earlier, UDP has no inbuilt handshake. This means that UDP allows for traffic to be sent to a given IP address without them acknowledging or accepting it. When the ratio of request size to response size is near one, this is largely a nonissue since an attacker gains very little by going through a third party to send the data. In this case, however, the attacker can send a very small amount of data (~52 bytes) and trigger a response of over 8000 134 byte packets. Because the connection sequence up to Connection Request Accepted is always the same and does not require the attacker to actually see the packets we respond with to respond correctly, the attacker can spoof the source IP header of the UDP packets it sends to the Geyser instance. This means that, because of this amplification vector, the Geyser instance can unwittingly be used to multiply the attacker\'s traffic by a theoretical maximum factor of 22,000. However, in practice, we saw that in the wild the actual multiplication factor was around 1000.\\n\\n\\n### Provider-Based Suspension\\n\\nIt is also important to consider that servers are generally hosted not locally, but with hosting providers. Hosting providers have a legitimate business interest in preventing their network from being used for abuse, as failing to do so could result in other hosting providers and ISPs blocking their traffic altogether. As a result, many hosting providers employ mechanisms to detect unusual traffic from their servers and will \u201cblack hole\u201d traffic to and from servers on their network emitting such traffic. This means that if an attacker wishes to take down a particular server, rather than overwhelm it with a traditional denial of service attack, they can simply make it appear as though the server itself is trying to engage in a denial of service attack. This will result in outbound traffic from the server being dropped by the provider, effectively having the same effect. We saw this occur, for example, with some Geyser services hosted on Hetzer as shown by the below MTR.\\n\\n\\n```sh\\nmtr pe.minetropical.net -rwbc 10  \\t \\nStart: 2024-03-28T18:24:58+0000\\nHOST: MS.local                                             \\tLoss%   Snt   Last   Avg  Best  Wrst StDev\\n  1.|-- 172.16.0.1                                            \\t0.0%\\t10\\t0.8   1.2   0.3   4.6   1.3\\n  2.|-- no-ptr.ziax.ltd (XXX.XXX.XXX.XXX)                       \\t0.0%\\t10\\t0.9   0.8   0.6   1.4   0.2\\n  3.|-- 62.7.117.42                                           \\t0.0%\\t10\\t7.5   7.6   7.2   8.4   0.3\\n  4.|-- core2-hu0-3-0-7.colindale.ukcore.bt.net (217.32.170.174)  0.0%\\t10\\t7.1   7.2   6.5   8.2   0.5\\n  5.|-- core6-hu0-3-0-15.faraday.ukcore.bt.net (109.159.252.134) 20.0%\\t10\\t7.5   7.7   7.0   9.0   0.6\\n  6.|-- 166-49-209-194.gia.bt.net (166.49.209.194)            \\t0.0%\\t10\\t7.5   7.6   7.2   8.8   0.5\\n  7.|-- t2c4-et-5-3-0.de-fra.gia.bt.net (166.49.195.103)      \\t0.0%\\t10   20.5  21.4  20.2  24.5   1.4\\n  8.|-- decix-gw.hetzner.com (80.81.192.164)                  \\t0.0%\\t10   20.8  20.8  20.3  22.0   0.4\\n  9.|-- core11.nbg1.hetzner.com (213.239.252.22)              \\t0.0%\\t10   25.8  26.2  25.5  29.3   1.2\\n 10.|-- blocked.hetzner.com (88.198.253.78)                   \\t0.0%\\t10   28.1  35.7  28.1  76.1  14.4\\n 11.|-- ???                                                  \\t100.0\\t10\\t0.0   0.0   0.0   0.0   0.0\\n 12.|-- blocked.hetzner.com (88.198.253.78)                  \\t90.0%\\t10  2906. 2906. 2906. 2906.   0.0\\n```\\n*MTR (My Traceroute) shows the path packets take to a given Geyser server. In the 10th and 12th hop, we can see that the packet is being routed to the hostname blocked.hetzner.com, implying traffic to the server is being null-routed.*\\n\\n\\n## Mitigation\\n\\nMultiple forms of mitigation for this bug, as well as preventive measures to guard against future attacks have been introduced into Geyser and its upstream networking library. These include proper reliability handling during the early RakNet connection, early cookie verification, and rate limiting.\\n\\n\\n### Proper Reliability Handling in Early RakNet Connection\\n\\nThe principal mitigation was changing the reliability type of the abused packet to unreliable. This means that the server will no longer respond to NAK requests for it, effectively leading to the attackers requests going unanswered. The packet capture below is taken from an instance with the reliability type of Connection Request Accepted changed to unreliable. We can see that the attacker simply continues to increment their packet range requested by NAK, but no response is provided.\\n\\n| ![Wireshark Mitigated Attack](/img/blog/2024-05-05-raknet-amplification-attack/wireshark-mitigated-attack.png) |\\n|:--:|\\n| *Wireshark packet capture of a Geyser instance under attack with a build mitigating the original attack vector. The attacker is seen sending NAK packets with a sequence range of as high as 40,959. However, since the packet was not sent as reliable, there is nothing for the Geyser instance to send in response.* |\\n\\n\\n### Early Cookie Verification\\n\\nThe underlying issue that allows for UDP amplification attacks is a lack of verification at an early stage of the connection. The original RakNet protocol actually specifies an optional solution for this. For context, RakNet was purchased by Oculus in 2014, and open sourced. Given the acquisition of Oculus by Facebook, the code for the original implementation is now archived by them. While Mojang\u2019s implementation of RakNet has some differences from the original, it does share many of the same features. In the packet Open Connection Reply 1, the original specification refers to a boolean HasSecurity, followed by a four byte cookie if the boolean is true.\\n\\n| ![Original RakNet Packets](/img/blog/2024-05-05-raknet-amplification-attack/original-raknet-packets.png) |\\n|:--:|\\n| *This is an excerpt from the original RakNet source containing the packet identifier enums. The comments above each enum define the packet structure. These packets from the initial login sequence are largely unchanged in Mojang\u2019s RakNet implementation, though it does not appear that the client has any support for full encryption as defined in the original specification. This can be inferred because when the HasSecurity boolean and cookie is sent by the server in Open Connection Reply 1, Open Connection Request 2 by the client does include the cookie, but sets the clientSupportsSecurity boolean to false.* |\\n\\nIt turns out that if a cookie is supplied by the Bedrock server in Open Connection Reply 1, the Bedrock client will reply with the same cookie. This allows us to effectively verify that the IP of the Bedrock client is not being spoofed by the third packet. Were the IP of the Bedrock client being spoofed, the packet containing the cookie would be sent to the victim\u2019s IP and be unknown to the attacker. If the attacker sends back an incorrect cookie, the connection can be terminated at that point.\\n\\n\\n### Rate Limiting\\n\\nIn addition, Cloudburst Network also implemented three main rate limits to prevent further potential abuse of the protocol. These are summarized in the table below.\\n\\n| Name                    | RakNet Connection Stage | Description                                          | Default |\\n| ----------------------- | ----------------------- | ---------------------------------------------------- | ------- |\\n| RAK_PACKET_LIMIT        | post-connection         | per-ip per-tick (10ms) post-connection packet limit  | 120     |\\n| RAK_GLOBAL_PACKET_LIMIT | post-connection         | per-tick (10ms) overall packet limit                 | 1000    |\\n\\nGeyser initially rolled out a fix that forced these defaults, but has since been [updated](https://github.com/GeyserMC/Geyser/pull/4532) to allow them to be configured with system properties that are documented on the [Geyser Wiki](https://wiki.geyser.fastly.8aka.cn/geyser/geyser-command-line-arguments-and-system-properties/#disabling-warnings-and-advanced-configuration).\\n\\nThese defaults may present an issue to those running a reverse proxy in front of their Geyser instance, particularly those utilizing DDoS mitigation services like TCPShield and CosmicGuard, as to Network it will appear that all connections are originating from the same IP. To make configuration on these services easier, Geyser will disable these rate limits provided proxy protocol is enabled for the bedrock connection, and the Geyser instance is properly configured to only accept connections from the IPs of the proxy. To simplify this configuration, Geyser\u2019s config can now accept a URL to specify proxy server IP ranges. Many DDoS mitigation providers have a static link to an always up to date text file of these.\\n\\n```yaml\\nbedrock:\\n# ...\\n  enable-proxy-protocol: true\\n  proxy-protocol-whitelisted-ips: [ \\"https://cosmic.global/ips/\\", \\"https://tcpshield.com/v4/\\" ]\\n```\\n*Geyser configuration using a URL pointing a new-line separated text file containing allowed IPs for proxy-protocol usage.*\\n\\n\\n## Long Term Impact\\n\\nIt is extremely important that all those running vulnerable instances of Geyser update as soon as possible. Failure to do so may result in your Geyser instance being used to harm others via UDP denial of service amplification. We continue to see this issue being exploited in the wild as of the writing of this post, and see no reason that will stop in the foreseeable future. The number of unpatched instances will likely decrease over time as Bedrock updates force server owners to update in order to support players on the latest Bedrock version.\\n\\n\\n## Acknowledgements \\n\\nWe thank the community for their patience as we addressed this issue, all those who responsibly disclosed this issue to us, the developers at Cloudburst and Geyser that worked to mitigate the issue, the server hosts that took an active role in ensuring instances on their hosting services were patched as soon as possible, all donors for their financial support of Geyser, and Cubecraft for their continued financial and operational support of the project."},{"id":"geyser-1-20-5","metadata":{"permalink":"/blog/geyser-1-20-5","source":"@site/blog/2024-05-02-geyser-1-20-5.md","title":"Geyser Available for Java 1.20.5/1.20.6","description":"Support for Java 1.20.5 and 1.20.6 has been released","date":"2024-05-02T00:00:00.000Z","tags":[],"readingTime":2.165,"hasTruncateMarker":true,"authors":[{"name":"Camotoy","title":"Project Lead","url":"https://github.com/Camotoy","imageURL":"https://github.com/Camotoy.png","key":"Camotoy","page":null}],"frontMatter":{"title":"Geyser Available for Java 1.20.5/1.20.6","slug":"geyser-1-20-5","authors":"Camotoy","hide_table_of_contents":false,"description":"Support for Java 1.20.5 and 1.20.6 has been released"},"unlisted":false,"prevItem":{"title":"RakNet Amplification Attack Summary and Response","permalink":"/blog/raknet-amplification-attack"},"nextItem":{"title":"Four Years of Geyser","permalink":"/blog/four-years-of-geyser"}},"content":"Support for Java 1.20.5 and 1.20.6 has been released. Thank you for your patience as we work on the update!\\n\\n\x3c!-- truncate --\x3e\\n\\n## New: item components\\n\\nGone is the item NBT to serialize extra data over the network. 1.20.5 introduces data components, which replaces the guesswork of NBT with strict objects attached to each class.\\n\\nWe\u2019ve also been able to get rid of unreachable code from before the server inventory rewrite, back when creative mode Bedrock had the potential ability to delete NBT from items just from moving them around.\\n\\n## NBT refactor\\n\\nSince items no longer have NBT, we decided it was a good time to switch to using one NBT library. Our Bedrock protocol library used [Cloudburst\u2019s NBT implementation](https://github.com/CloudburstMC/NBT), whereas our Java protocol library used OpenNBT. The latter has been severely neglected, and still has several cases of weird or outdated implementations, such as tag names being present in tag value objects. The entire project now uses Cloudburst\u2019s NBT library, which is far nicer to use overall:\\n\\n```java\\nboolean piglinSafe = ((Number) dimension.get(\\"piglin_safe\\").getValue()).byteValue() != (byte) 0;\\n```\\n\\nChanges to:\\n\\n```java\\nboolean piglinSafe = dimension.getBoolean(\\"piglin_safe\\");\\n```\\n\\n## Better tag extensibility\\n\\nBlock and item tags are now enums - this example diff to add support for _one_ tag\u2026\\n\\n![Tag Enums](/img/blog/2024-05-02-geyser-1-20-5/tag-enums.png)\\n\\n\u2026would now be adding one line of a new enum in [the ItemTag class](https://github.com/GeyserMC/Geyser/blob/8b7b8cdffdb7aba97ef817037859d1151f4b2665/core/src/main/java/org/geysermc/geyser/session/cache/tags/ItemTag.java). And we had to add a handful of enums to add support for [data-driven animal loved foods](https://github.com/GeyserMC/Geyser/commit/59a2c0dc02abacd00fe3a72788cc9317c891557e)... imagine the complexity with the first style of code!\\n\\n## No more trim recipe hardcoding\\n\\nBecause the server now sends all trim recipes through a packet as a registry, we\u2019re able to get rid of this block of code that was required for trim recipes to be handled. Yay to no hardcoding!\\n\\n![Trim Recipes](/img/blog/2024-05-02-geyser-1-20-5/trim-recipes.png)\\n\\n## Entity properties\\n\\nBedrock\u2019s newer [entity property system](https://learn.microsoft.com/en-us/minecraft/creator/documents/introductiontoentityproperties?view=minecraft-bedrock-stable) has now found a use in vanilla Bedrock - it controls the armadillo\u2019s animation state (and without it, an armadillo will default to staying inside its shell!). [Kastle](https://github.com/Kas-tle) came through and [ported some work-in-progress code](https://github.com/GeyserMC/Geyser/commit/99e6a2981da27a9ec8f09c04cfc8e73a296e4263) so Geyser is able to work with the new system. \\n\\n## Special Thanks\\n\\nThis update would have been a nightmare without the many hands we had to help implement everything we needed to get done.\\n\\n[basaigh](https://github.com/basaigh) implemented the huge item changes in MCProtocolLib in a very timely fashion, meaning that Geyser could get right to updating its own code.\\n\\n[AJ Ferguson](https://github.com/AJ-Ferguson) and [Chris](https://github.com/onebeastchris) both helped with implementing new features and fixing regressions.\\n\\n[Kastle](https://github.com/Kas-tle), hot off the heels of stronger security protections on the Bedrock side, assisted with custom skull reimplementation and entity properties implementation."},{"id":"four-years-of-geyser","metadata":{"permalink":"/blog/four-years-of-geyser","source":"@site/blog/2023-07-08-four-years-of-geyser.md","title":"Four Years of Geyser","description":"Geyser is now four years old!","date":"2023-07-08T00:00:00.000Z","tags":[],"readingTime":4.845,"hasTruncateMarker":true,"authors":[{"name":"RednedEpic","title":"Project Lead","url":"https://github.com/Redned235","imageURL":"https://github.com/Redned235.png","key":"RednedEpic","page":null}],"frontMatter":{"title":"Four Years of Geyser","slug":"four-years-of-geyser","authors":"RednedEpic","hide_table_of_contents":false,"description":"Geyser is now four years old!"},"unlisted":false,"prevItem":{"title":"Geyser Available for Java 1.20.5/1.20.6","permalink":"/blog/geyser-1-20-5"},"nextItem":{"title":"Looking back at 2022","permalink":"/blog/looking-back-at-2022"}},"content":"Hi everyone,\\n\\nToday is a super special day - it\'s Geyser\'s birthday \ud83e\udd73. Geyser is now four years old and booyyy has it come a long way! This is a huge day for us and an incredible milestone. We\'re very proud of how far we\'ve been able to come, the amount of servers Geyser has expanded the reach of, and the amazing community behind Geyser. Seeing millions of players being able to play with their Java friends is something I never dreamed Geyser would be able to do. The growth from day one has been amazing and we\'re all very grateful for everyone\'s support \ud83d\udc99 \\n\\nNot only is this a special day because it\'s our birthday, but we have some exiting news and sneak peeks to share with you all, alongside general updates on our project development. Continue reading for more information!\\n\\n\x3c!-- truncate --\x3e\\n\\n## Project Statistics \\n- Since the start of the project, there have been 3,337 commits contributed by 105 contributors\\n- As of just a few days ago, Geyser has hit 4,000 stars on GitHub, making it one of the top open-source Minecraft projects ever, and _the_ #1 Minecraft Bedrock project\\n- Our Discord server has continued to grow, now approaching 25,000 Discord members\\n\\n![image](https://github.com/GeyserMC/GeyserBlog/assets/29153871/e2d83a49-aa94-46c4-b660-4bc150331818)\\n\\nNone of these would have been possible without our amazing community. To that, we owe a debt of gratitude for the years of support from all of you \ud83d\udc99\\n\\n## Project Development\\nIt\'s likely well-known by now that Geyser has hit a state of maturity. Since about 2021, Geyser has reached the point of full survival and creative playability for Bedrock clients on Java servers. This has allowed us to place much more focus on improving stability, fixing bugs and designing a resilient platform. We\'ve spent the latter half of last year designing an API for Geyser, creating an extension system, and ultimately adding more for developers. A couple notable additions include custom item support and a resource pack API.\\n\\nWe\'ve also made some major internal changes, one of the biggest being updating our Bedrock protocol library to version 3.0. This was a massive undertaking by the [CloudburstMC](https://github.com/CloudburstMC/) organization, which we work closely with. While a bit bumpy at first, these changes modernized the internal RakNet library and brought along some sweet network optimizations on the Bedrock side.\\n\\nAt a steady pace, we\'re also working on integrating Floodgate and Geyser together! While Floodgate will still exist as a separate project for proxy and standalone instances, we are working on shipping it inside Geyser to improve setup processes and reduce complexity when creating Geyser servers. One of our goals internally has been to make the Geyser setup as seamless as possible, and this is just one way we\'re doing that! We\'ll share more on this once it gets closer to completion.\\n\\n## What\'s Next?\\nWith Geyser being in a state of maturity in terms of vanilla compatibility, we\'re shifting our attention onto expanding all the \\"custom\\" features Bedrock supports. There\'s a huge and growing demand for utilizing many of Bedrock\'s custom features, such as resource packs, entities, blocks, items and UIs. One of our biggest goals going forward is to design a platform that allows developers and server owners to bring their server to the next level for Bedrock players.\\n\\n### API Additions\\nRecently, we added a [resource pack loading API](https://github.com/GeyserMC/Geyser/pull/3696) which allows for developers to fine-tune and integrate their resource packs through the Geyser API, and are actively working on even more, such as [custom blocks](https://github.com/GeyserMC/Geyser/pull/3505) and [custom entities](https://github.com/GeyserMC/Geyser/pull/3754). These are just a few things we\'re doing inside the Geyser API, but that\'s not all we have in store!\\n\\n### Resource Pack Conversion\\nSome of you who were around a few years ago may remember we used to maintain a resource pack conversion project. Well, we\'ve decided to [revive this project](https://github.com/GeyserMC/PackConverter/tree/feature/refactor)! While we know that third party projects exist now and handle conversions fairly well, we\'re working to make this part of mainline Geyser to further simplify the work needed by server owners and plugin developers. This means that once the project is integrated into Geyser, pack conversion will happen automatically. Contributions are most certainly welcome and please do reach out on Discord if you\'d like to get involved!\\n\\n### Wait, there\'s more???\\nThere is! And the exciting news is we\'re expanding Geyser to Forge! Of all the major platforms we support, Forge is one of the ones we do not support. We want to further expand the Geyser ecosystem, and I\'m happy to announce that Geyser is coming to Forge in the next couple of weeks! This will also include some improvements to the Fabric platform as well. One such change is an integrated world manager, which exists only on Spigot platforms currently. This means Geyser will use the server to retrieve things such as blocks, significantly reducing the amount of RAM used for caching world data. \\n\\nAdditionally, since the Forge and Fabric platforms will use a common codebase for 95% of everything, thanks to [Architectury](https://github.com/architectury/), we can update both platforms very easily and changes that happen to one in most cases will carry over to the other.\\n\\n### One more thing...\\nNot only are we wanting to expand what Geyser can do with custom features on _vanilla_ servers, but there\'s a **lot** we want to do with both Fabric and Forge in the near future. Keep an eye out for further announcements over the next few weeks \ud83d\udc40\ud83c\udf70\ud83e\udd73 \\n\\n![Minecraft 7_8_2023 2_15_26 PM](https://github.com/GeyserMC/GeyserBlog/assets/29153871/5f60d150-3081-4fe8-9dba-ce04d8edcd85)\\n\\nAnd that\'s all I have to share for today! Once again, thank you all for your continued support over the years and we cannot wait to see the creativity you unleash on your server with these features! In typical Geyser fashion, here is a Gource render of all commits since the start of the project: [https://youtu.be/ss6GlUkVgEE](https://youtu.be/ss6GlUkVgEE)"},{"id":"looking-back-at-2022","metadata":{"permalink":"/blog/looking-back-at-2022","source":"@site/blog/2023-01-02-Looking-back-at-2022.md","title":"Looking back at 2022","description":"A look back at the year of 2022 for Geyser.","date":"2023-01-02T00:00:00.000Z","tags":[],"readingTime":3.895,"hasTruncateMarker":true,"authors":[{"name":"Camotoy","title":"Project Lead","url":"https://github.com/Camotoy","imageURL":"https://github.com/Camotoy.png","key":"Camotoy","page":null}],"frontMatter":{"title":"Looking back at 2022","slug":"looking-back-at-2022","authors":"Camotoy","hide_table_of_contents":false,"description":"A look back at the year of 2022 for Geyser."},"unlisted":false,"prevItem":{"title":"Four Years of Geyser","permalink":"/blog/four-years-of-geyser"},"nextItem":{"title":"1.18 Release, MCProtocolLib, Refactors & More!","permalink":"/blog/1-18-release-and-more"}},"content":"Hi.\\n\\n2022 for Geyser was, in comparison to other years, rather unremarkable in terms of new features. Whereas 2021 had Bedrock skin support and complete inventory support, and 2020 had movement fixes, this year felt largely like a maintenance year. I think that\u2019s a good thing; it means we\u2019ve reached the point where the only things left to do are bug fixes, niche features/behavior, or updates. Even so, here are some of the notable points from Geyser in 2022, and what\u2019s next.\\n\\n\x3c!-- truncate --\x3e\\n\\n## Yearly GitHub Stats\\n\\nIn 2022, we had 519 commits from 59 contributors, 85 merged PRs, and 869 new stars on the repository. The reach Geyser continues to get every year is positively astounding.\\n\\n## (Nearly) Every Floodgate Instance Breaking\\n\\nOn February 2nd, 2022, Mojang snuck in a change to their API which resulted in almost every Floodgate instance involving the Paper server software breaking (likely due to [this](https://github.com/PaperMC/Paper/blob/0cc2503b88343c4d10d9e6ecf7592d56762b4cae/patches/server/0183-Ability-to-change-PlayerProfile-in-AsyncPreLoginEven.patch#L38) Paper patch) - even Floodgate instances only on the proxy. We swiftly put mitigations in place, and while I hope such an issue never has to happen again, the day presented a once-in-a-lifetime unique challenge in fixing a sudden, serious bug that we did not induce, and it\u2019s a reminder that part of the job at Geyser is working around whatever changes Mojang throws at us, inside or outside of updates.\\n\\n## Custom Item Support\\n\\nFinally, Java\u2019s CustomModelData system is now supported on Bedrock. This change is largely thanks to [ImDaBigBoss](https://github.com/ImDaBigBoss), who created the [PR](https://github.com/GeyserMC/Geyser/pull/2822) back in February, and [Kastle](https://github.com/Kas-tle), who has worked to map Java packs to Bedrock as effortlessly as possible. \\n\\n## Dedicated Wiki\\n\\nWe now have a [dedicated wiki](https://wiki.geyser.fastly.8aka.cn/), allowing users to contribute documentation without allowing random changes from anyone.\\n\\n## Extensions\\n\\nAfter two years of theory and concepts, Geyser extensions are now possible, allowing for improved interaction with Bedrock clients to take advantage of what the Bedrock platform has to offer. These work very similar to plugins and allow for developers to write code specifically for Bedrock and Geyser features using the Geyser API. In 2023, we hope to see more API additions that allow for servers, plugins and mods to shine in creativity.\\n\\n## Geyser-Fabric Joins the Main Repository\\n\\nGeyser-Fabric is now a part of the main Geyser repository, instead of being relegated to a separate repository. This will ensure that the Fabric mod always gets the latest changes to Geyser, and isn\u2019t prone to losing out on updates.\\n\\n## Secure Profiles and Geyser\\n\\nThe 1.19 Java updates added new changes that allowed player chat to be verified and reported to Mojang. Bedrock as it stands is essentially incompatible with these changes; before 1.19.3, requiring that all players chat securely (enabling `enforce-secure-profile` in `server.properties`) would prevent Bedrock from joining. Thankfully, in 1.19.3, that same setting now allows Bedrock players to join, just without the ability to chat.\\n\\n## Almost 100% Day-One Updates\\n\\nI\u2019m very proud of all our developers and contributors that are able to get updates ready before each Minecraft release. Two years ago for 1.16, we were unable to have an update ready before the release date. Now, we are in a place to be consistently prepared for supporting auto-updating Bedrock clients by having a Geyser version released by the day of. The almost exception this year was the Bedrock 1.19.21 update released in August - while it was supposed to be a patch update, it surprised the entire Bedrock community (even featured servers) by being incompatible with the prior 1.19.20 version without any notice from Mojang. There was no notable difference, and we were able to push an update in about an hour after we discovered the incompatibility.\\n\\n## Upcoming: Geyser and Floodgate Merge\\n\\nAs we look to 2023, one of my goals as a project lead on Geyser is ensuring the setup and update process is as smooth and secure as possible. Having two plugins for users to worry about isn\u2019t fun, and many support requests we get have no idea that they need Floodgate for Bedrock players to join without needing a Java account. While Floodgate has to stick around for backend servers and Geyser Standalone, we want to package Floodgate functionality into Geyser for improved efficiency, to fix some [annoying bugs](https://github.com/GeyserMC/Floodgate/issues/178) where having duplicate classes causes API errors, and to simplify how many plugins you need to install to get Geyser running.\\n\\n\\nOverall, I\u2019m really happy and very grateful to see Geyser where it is today. We have 20,000 running Geyser instances, with 10,000 players combined on all of them. We have an amazing community, and the support of many in the wider Minecraft community. 2023 promises more good changes - here\u2019s to it!"},{"id":"1-18-release-and-more","metadata":{"permalink":"/blog/1-18-release-and-more","source":"@site/blog/2021-12-28-1-18-release-and-more.md","title":"1.18 Release, MCProtocolLib, Refactors & More!","description":"In this post, we will be covering all the changes that led up to the 1.18 release.","date":"2021-12-28T00:00:00.000Z","tags":[],"readingTime":11.64,"hasTruncateMarker":true,"authors":[{"name":"RednedEpic","title":"Project Lead","url":"https://github.com/Redned235","imageURL":"https://github.com/Redned235.png","key":"RednedEpic","page":null}],"frontMatter":{"title":"1.18 Release, MCProtocolLib, Refactors & More!","slug":"1-18-release-and-more","authors":"RednedEpic","hide_table_of_contents":false,"description":"In this post, we will be covering all the changes that led up to the 1.18 release."},"unlisted":false,"prevItem":{"title":"Looking back at 2022","permalink":"/blog/looking-back-at-2022"}},"content":"Hi everyone \ud83d\udc4b\\n\\nWelcome to the new Geyser blog! We\u2019ll be posting new content here periodically about project updates, future plans, project announcements and really just miscellaneous development-related content around the Geyser project(s). These will be linked in our #blog-feed channel on Discord, so if you want to be notified when we make new posts and such, feel free to either follow the channel in your own Discord server, or turn on notifications.\\n\\n\x3c!-- truncate --\x3e\\n\\n## Introduction: {#introduction}\\nIn this post, we will be covering all the changes that led up to the 1.18 release. With 1.18 came a huge set of changes for Geyser which although may not be visible to the end user, were a massive feat internally. This resulted in not only multiple project refactors of Geyser along with surrounding projects (PacketLib, MCProtocolLib, etc.) but many additional optimizations and improvements to how the code operated and ran. For the latter half of 2021 especially, we\u2019ve been putting in a lot more time to ensure Geyser runs more smoothly and to optimize poorly performing parts of the code, so much of these changes were a direct result of that initiative.\\n\\n## Writing a New Java Edition Protocol Library: {#writing-a-new-java-edition-protocol-library}\\nTo preface, we were not initially planning to do this big refactor all at once, but one thing led to another and here we are. Our initial plans were actually quite a bit different, with us initially planning to deprecate and remove MCProtocolLib from our codebase, [and instead implement support for Java Edition](https://github.com/GeyserMC/Protocol/tree/feature/java-3.0) inside of [Protocol](https://github.com/CloudburstMC/Protocol), our Bedrock Edition protocol library. We actually got it to a point where you could join and properly send/receive packets quite well!\\n\\n![Java Edition Lib](https://user-images.githubusercontent.com/29153871/144722769-88a6701f-4478-4608-96ae-a5c855b752b7.png)\\n\\nThis was inline with our plans to continually improve performance and maintainability with Geyser, since using a library where much of the code is the same across both the Java & Bedrock protocol libraries would reduce much of the additional work we need to do in. A good example of this is inside our [ItemTranslator](https://github.com/GeyserMC/Geyser/blob/master/core/src/main/java/org/geysermc/geyser/translator/inventory/item/ItemTranslator.java#L295-L357) class, where we translate NBT objects from that used inside of MCProtocolLib, to that used inside of our Bedrock protocol library. We were intending to have this done with 1.18 since the update itself was not too drastic, meaning we could spend much more time on Geyser itself, rather than trying to update to the protocol.\\n\\n## Taking over MCProtocolLib: {#taking-over-mcprotocollib}\\nHowever our plans completely changed when Steveice10, the maintainer of MCProtocolLib at the time, reached out [and asked if we wanted to take over the project](https://github.com/GeyserMC/MCProtocolLib/issues/659). At first we were a bit hesitant as we had already put in quite a bit of work to our new library, but as MCProtocolLib was already an integral part of Geyser from [the very beginning](https://github.com/GeyserMC/Geyser/commit/17b99a80fe910ba7147aa4f3cd2669b5538422c7) and we had essentially been maintaining the library for the past year or so, we all came to the consensus that scrapping the library would be a poor idea, both for us as well as the wider community who was also using this library. We decided to take over it.\\n\\nWith us now being in full control of MCProtocolLib, that gave us much more freedom to update and improve the project that we previously were unable to do. Rather than go on with a new library altogether, we felt it would be better to gradually port over much of our work into MCProtocolLib. With the release of 1.18 still lingering, we decided to jump the gun and start on a massive refactor of packets, with us adopting Mojang-mapped packet names. This is something we were doing inside of Protocol for Java Edition and with more and more projects adopting these names and for the sake of unity across the board, we felt now was the best time to make this decision. \\n\\n## Improving Performance in MCProtocolLib: {#improving-performance-in-mcprotocollib}\\nDuring the process of renaming packets to use Mojmap names, we found that most of the performance bottlenecks with MCProtocolLib & Geyser did not particularly lie with object translation, since it\'s relatively cheap in the grand scheme of things, but just the ways in which the library operated itself.\\n\\n![Slow Packets](https://user-images.githubusercontent.com/29153871/144722843-4bef937f-b393-487d-99fc-cc56a8eece58.PNG)\\n\\nWhat we identified is that inside of MinecraftProtocol, the main class inside of MCProtocolLib, that it was re-registering the Minecraft protocol individually for every player individually, any time the protocol state changed. To give a bit more background on this - the Minecraft protocol operates over four individual state. The first is the handshaking state, which is the state set when a client first makes a connection the Minecraft server. Once the handshake has completed, the next state is either the `login` or the `status` state. The status state is set when a client pings the server from the server list and never actually joins, while the login state is for when the client is logging into the server. Once the login is complete, the server then goes on to the `game` state, where you actually recieve packets that let you interact with the world.\\n\\nBelow is an example of what MCProtocolLib was doing previously, any time you switched from the `login` state to the `game` state:\\n\\n```java\\nprivate void initGame(BiConsumer<Integer, Class<? extends Packet>> clientboundPackets, BiConsumer<Integer, Class<? extends Packet>> serverboundPackets) {\\n        clientboundPackets.accept(0x00, ServerSpawnEntityPacket.class);\\n        clientboundPackets.accept(0x01, ServerSpawnExpOrbPacket.class);\\n        clientboundPackets.accept(0x02, ServerSpawnLivingEntityPacket.class);\\n        clientboundPackets.accept(0x03, ServerSpawnPaintingPacket.class);\\n        clientboundPackets.accept(0x04, ServerSpawnPlayerPacket.class);\\n        clientboundPackets.accept(0x05, ServerAddVibrationSignalPacket.class);\\n        clientboundPackets.accept(0x06, ServerEntityAnimationPacket.class);\\n        clientboundPackets.accept(0x07, ServerStatisticsPacket.class);\\n        clientboundPackets.accept(0x08, ServerPlayerActionAckPacket.class);\\n        clientboundPackets.accept(0x09, ServerBlockBreakAnimPacket.class);\\n        clientboundPackets.accept(0x0A, ServerUpdateTileEntityPacket.class);\\n        clientboundPackets.accept(0x0B, ServerBlockValuePacket.class);\\n        clientboundPackets.accept(0x0C, ServerBlockChangePacket.class);\\n        clientboundPackets.accept(0x0D, ServerBossBarPacket.class);\\n        clientboundPackets.accept(0x0E, ServerDifficultyPacket.class);\\n        clientboundPackets.accept(0x0F, ServerChatPacket.class);\\n        clientboundPackets.accept(0x10, ServerClearTitlesPacket.class);\\n        clientboundPackets.accept(0x11, ServerTabCompletePacket.class);\\n        clientboundPackets.accept(0x12, ServerDeclareCommandsPacket.class);\\n        clientboundPackets.accept(0x13, ServerCloseWindowPacket.class);\\n        clientboundPackets.accept(0x14, ServerWindowItemsPacket.class);\\n        clientboundPackets.accept(0x15, ServerWindowPropertyPacket.class);\\n        clientboundPackets.accept(0x16, ServerSetSlotPacket.class);\\n        clientboundPackets.accept(0x17, ServerSetCooldownPacket.class);\\n        clientboundPackets.accept(0x18, ServerPluginMessagePacket.class);\\n        // this continues for more than 100 more packets\\n```\\n\\nWith the above code, every game packet would be registered into a new map. This was a far less than ideal situation, given that hundreds of packets would be registered, and this was something called for every client. We opted to replace this with a [static registry](https://github.com/GeyserMC/MCProtocolLib/blob/master/src/main/java/com/github/steveice10/mc/protocol/codec/MinecraftCodec.java) which instead holds these values just once. Any time the sub-protocol changes, it instead just pulls from this static codec instead, rather than populating a map every time.\\n\\nWe also identified other areas where code was running poorly - previously, every packet was constructed through reflection, which we realized could easily be replaced with a packet factory. Nowadays, the packet registration code is only constructed once, and the player\'s protocol state determines which map to pull packets from.\\n\\nWith all these changes consolidated into an individual codec, it also opens the door for multi-version compatibility - something we were initially planning to do with our Java Edition work in Protocol. Although not officially supported yet nor something we have fully committed to, these changes will allow that capability in the future, and implementing projects technically could implement the capability to do so if they please.\\n\\n## Refactoring Geyser: {#refactoring-geyser}\\nWith the massive changes inside MCProtocolLib already lining up, we already foresaw the changes in Geyser being quite drastic. With plans for extensions and a more streamlined API being in the plans for over a year, we felt that now was the best time to start moving along with that. This initially started with a massive refactor of the packages inside of Geyser. Previously, everything involved with the work Geyser did with packet translation and whatnot lied in the `connector` module of the project. This name was slightly confusing for many as Geyser does much more than just \\"connecting you to a server.\\" With that being said, we decided to rename the module to `core` and update the packaging for it from `org.geysermc.connector` to `org.geysermc.geyser`. \\n\\nAlong with the package name changes, we decided to start implementing a new API. At the time of writing, this is still something that is very much a work in progress, however this will make it much easier to write projects that interop with Geyser & Floodgate in a much more streamlined fashion, and allow for extensions to have a solid base to build off of.\\n\\n## Improving Code in Geyser: {#improving-code-in-geyser}\\nAs mentioned earlier in this post, one of our plans was to eventually move away from MCProtocolLib due to the additional translation we have to do between MCProtocolLib and Protocol objects. However, as we continued working on both the MCProtocolLib changes and the Geyser refactor, we identified that these translations were not the sources of most performance bottlenecks inside of Geyser itself. This led to us refactoring our entity system inside of Geyser, not solely for the sake of performance, but also for the sake of better usability and understanding.\\n\\n```java\\npublic void updateBedrockMetadata(EntityMetadata entityMetadata, GeyserSession session) {\\n        switch (entityMetadata.getId()) {\\n            case 0:\\n                if (entityMetadata.getType() == MetadataType.BYTE) {\\n                    byte xd = (byte) entityMetadata.getValue();\\n                    metadata.getFlags().setFlag(EntityFlag.ON_FIRE, ((xd & 0x01) == 0x01) && !metadata.getFlags().getFlag(EntityFlag.FIRE_IMMUNE)); // Otherwise immune entities sometimes flicker onfire\\n                    metadata.getFlags().setFlag(EntityFlag.SNEAKING, (xd & 0x02) == 0x02);\\n                    metadata.getFlags().setFlag(EntityFlag.SPRINTING, (xd & 0x08) == 0x08);\\n                    // Swimming is ignored here and instead we rely on the pose\\n                    metadata.getFlags().setFlag(EntityFlag.GLIDING, (xd & 0x80) == 0x80);\\n\\n                    setInvisible(session, (xd & 0x20) == 0x20);\\n                }\\n                break;\\n            case 1: // Air/bubbles\\n                setAir((int) entityMetadata.getValue());\\n                break;\\n            case 2: // custom name\\n                if (entityMetadata.getValue() instanceof Component message) {\\n                    // Always translate even if it\'s a TextMessage since there could be translatable parameters\\n                    metadata.put(EntityData.NAMETAG, MessageTranslator.convertMessage(message, session.getLocale()));\\n                }\\n                break;\\n            case 3: // is custom name visible\\n                if (!this.is(PlayerEntity.class))\\n                    metadata.put(EntityData.NAMETAG_ALWAYS_SHOW, (byte) ((boolean) entityMetadata.getValue() ? 1 : 0));\\n                break;\\n            case 4: // silent\\n                metadata.getFlags().setFlag(EntityFlag.SILENT, (boolean) entityMetadata.getValue());\\n                break;\\n            case 5: // no gravity\\n                metadata.getFlags().setFlag(EntityFlag.HAS_GRAVITY, !(boolean) entityMetadata.getValue());\\n                break;\\n            case 6: // Pose change - typically used for bounding box and not animation\\n                Pose pose = (Pose) entityMetadata.getValue();\\n\\n                metadata.getFlags().setFlag(EntityFlag.SLEEPING, pose.equals(Pose.SLEEPING));\\n                // Triggered when crawling\\n                metadata.getFlags().setFlag(EntityFlag.SWIMMING, pose.equals(Pose.SWIMMING));\\n                setDimensions(pose);\\n                break;\\n            case 7: // Freezing ticks\\n                // The value that Java edition gives us is in ticks, but Bedrock uses a float percentage of the strength 0.0 -> 1.0\\n                // The Java client caps its freezing tick percentage at 140\\n                int freezingTicks = Math.min((int) entityMetadata.getValue(), 140);\\n                setFreezing(session, freezingTicks / 140f);\\n                break;\\n        }\\n    }\\n```\\n\\nLooking at the code above, our previous code for translating entity metadata was extremely scattered and utilized many magic \u201cnumbers\u201d associated with entity translation. These types of switch statements were all over various entity classes, and were quite messy. \\n\\nTo explain the above code in more detail - the way Minecraft Java sends entity metadata over the protocol is that it associates an id for every entity metadata \u201ctype\u201d. Looking at the above code, id 3 for example, is associated with whether an entity\u2019s name is visible above their head. The problem with handling our code like this is that if Mojang decides to add a new entity metadata field at id 2 for example, everything above that will be incremented by 1, so \'custom name visible\' would have an id of 4, rather than 3 in future updates. Along with the code being so scattered, it meant that we would need to increment ids inside of _every_ entity class, which was far less than ideal.\\n\\nWhat we opted to do to remedy this issue is to instead not use massive if or switch statements on the ids, but to register these values inside of a list, and add them based on the order they should be translated in.\\n\\n```java\\nEntityDefinition<Entity> entityBase = EntityDefinition.builder((BaseEntityFactory<Entity>) Entity::new)\\n        .addTranslator(MetadataType.BYTE, Entity::setFlags)\\n        .addTranslator(MetadataType.INT, Entity::setAir) // Air/bubbles\\n        .addTranslator(MetadataType.OPTIONAL_CHAT, Entity::setDisplayName)\\n        .addTranslator(MetadataType.BOOLEAN, Entity::setDisplayNameVisible)\\n        .addTranslator(MetadataType.BOOLEAN, (entity, entityMetadata) -> entity.setFlag(EntityFlag.SILENT, ((BooleanEntityMetadata) entityMetadata).getPrimitiveValue()))\\n        .addTranslator(MetadataType.BOOLEAN, Entity::setGravity)\\n        .addTranslator(MetadataType.POSE, Entity::setPose)\\n        .addTranslator(MetadataType.INT, Entity::setFreezing)\\n        .build();\\n```\\n\\nAll that code shown earlier has been condensed into the following. Now, if Mojang is to add a new metadata field at id 2 for instance, we can simply just plug it in as the third value, and boom, everything else will automatically be incremented!\\n\\nIn regards to performance, previously all the entity data had been held in an EntityType enum, which was not the best for constructing more complex entity objects. This meant we had to use reflection for constructing entities which as mentioned earlier, was used inside of MCProtocolLib, and was slower than what we wanted. This too was replaced with an entity factory, and can be seen in the above code snippet.\\n\\n## New API, Extensions, and Looking Onward: {#new-api-extensions-and-looking-onward}\\nAs brought up multiple times throughout this post, we have been spending time working up a new API. We eventually want to bring in extensions to Geyser, which act as plugins on their own except they are loaded from Geyser itself. With more and more people and larger servers adopting Geyser, many more unique and niche usecases have popped up which don\u2019t particularly fit inside of Geyser itself, but would still benefit users as a whole. As Geyser is capable of running on 6 platforms at this point in time (Spigot, Sponge, Standalone, Velocity, Fabric and BungeeCord, with Forge likely on the way), as a developer, creating a separate addon capable of running on all these platforms is far less than ideal. We\u2019ve opted to get around this by creating a new extension system, allowing developers to create an extension one time for Geyser, and it being capable of running on any of these platforms.\\n\\nThis extension API has not been created yet however, and plans for the base API inside of Geyser are still being finalized. We also intend to start moving most of Floodgate into Geyser itself, so unless you are running Floodgate independently from Geyser (e.g. you use Geyser Standalone but run Floodgate on the proxy), in the near future you will only need to install Geyser, and Floodgate\u2019s functions will all be handled automatically in Geyser.\\n\\nWith that coming up, we also want to design the base API to be agnostic in the sense that basic functions such as retrieving how many players are online can be done using the same API, whether the server has just Geyser installed or just Floodgate. But at the same time, we also want to make it easy to utilize a more-specific Floodgate and Geyser API. \\n\\nAnyway, that about wraps up the first post! Thanks for reading and feel free to offer any feedback about the topics covered in our [Discord server](https://discord.gg/geysermc)!"}]}}')}}]);